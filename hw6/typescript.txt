Script started on 2021-10-27 11:17:40-04:00 [TERM="xterm-256color" TTY="/dev/pts/1" COLUMNS="126" LINES="20"]
]0;djv78@maroon33: ~/Documents/GitHub/CS374Work/hw6[01;32mdjv78@maroon33[00m:[01;34m~/Documents/GitHub/CS374Work/hw6[00m$ cat calcPi[KI2.c
/* calcPI2.c calculates PI using POSIX threads.
 * Since PI == 4 * arctan(1), and arctan(x) is the 
 *  integral from 0 to x of (1/(1+x*x),
 *  the for loop below approximates that integration.
 *
 * Joel Adams, Calvin College, Fall 2013.
 *
 * Usage: ./calcPI2 [numIntervals] [numThreads]
 * 
 * Edited by Duncan Van Keulen for High Performance Computing Homework 6
 * At Calvin University, 22 October 2021 to use the pthreadReductionSum pattern
 */

#include <stdio.h>                 // printf(), fprintf(), etc.
#include <stdlib.h>                // strtoul(), exit(), ...
#include <mpi.h>                   // MPI_Wtime()
#include "pthreadReductionSum.h"   // pthreads, pthreadReductionSum

// global variables (shared by all threads 
volatile long double pi = 0.0;       // our approximation of PI 
pthread_mutex_t      piLock;         // how we synchronize writes to 'pi' 
long double          intervals = 0;  // how finely we chop up the integration 
unsigned long        numThreads = 0; // how many threads we use 


/* compute PI using the parallel for loop pattern
 * Parameters: arg, a void* 
 * Preconditions: 
 *   - non-locals intervals and numThreads are defined.
 *   - arg contains the address of our thread's ID.
 * Postcondition: non-local pi contains our approximation of PI.
 */
void * computePI(void * arg)
{
    long double   x,
                  width,
                  localSum = 0;
    unsigned long i,
                  threadID = *((unsigned long *)arg);

    width = 1.0 / intervals;

    for(i = threadID ; i < intervals; i += numThreads) {
        x = (i + 0.5) * width;
        localSum += 4.0 / (1.0 + x*x);
    }

    localSum *= width;
    
    // reduce all of the values in the array using a barrier
    pthreadReductionSum(localSum, numThreads, threadID, &pi);
    
    return NULL;
} 

/* process the command-line arguments
 * Parameters: argc, an int; and argv a char**.
 * Postcondition:
 *  - non-locals intervals and numThreads have been defined.
 *     according to the values the user specified when
 *     calcPI2 was invoked.
 */
void processCommandLine(int argc, char ** argv) {
   if ( argc == 3 ) {
      intervals = strtoul(argv[1], 0, 10);
      numThreads = strtoul(argv[2], 0, 10); 
   } else if ( argc == 2 ) {
      intervals = strtoul(argv[1], 0, 10);
      numThreads = 1;
   } else if ( argc == 1 ) {
      intervals = 1;
      numThreads = 1;
   } else {
      fprintf(stderr, "\nUsage: calcPI2 [intervals] [numThreads]\n\n");
      exit(1);
   }
}
      

int main(int argc, char **argv) {
    pthread_t * threads;            // dynamic array of threads 
    unsigned long  * threadID;      // dynamic array of thread id #s 
    unsigned long i;                // loop control variable 
    double startTime = 0,           // timing variables
           stopTime = 0;
           
    MPI_Init(&argc, &argv);

    processCommandLine(argc, argv);

    threads = malloc(numThreads*sizeof(pthread_t));
    threadID = malloc(numThreads*sizeof(unsigned long));
    pthread_mutex_init(&piLock, NULL);
    commArray = malloc(numThreads*sizeof(long double));

    startTime = MPI_Wtime();

    for (i = 0; i < numThreads; i++) {   // fork threads
        threadID[i] = i;
        pthread_create(&threads[i], NULL, computePI, threadID+i);
    }

    for (i = 0; i < numThreads; i++) {   // join them
        pthread_join(threads[i], NULL);
    }
    stopTime = MPI_Wtime();

    printf("Estimation of pi is %32.30Lf in %lf secs\n", pi, stopTime - startTime);
    printf("(actual pi value is 3.141592653589793238462643383279...)\n");
   
    MPI_Finalize();
    pthread_mutex_destroy(&piLock);
    free(threads);
    free(threadID);
    return 0;
}

]0;djv78@maroon33: ~/Documents/GitHub/CS374Work/hw6[01;32mdjv78@maroon33[00m:[01;34m~/Documents/GitHub/CS374Work/hw6[00m$ cat pthreadReductionSum.h 
/* calcPI2.c calculates PI using POSIX threads.
 * Reduction pattern using pthreads
 *
 * Duncan Van Keulen for High Performance Computing Homework 6
 * At Calvin University, 22 October 2021
 */
#include "pthreadBarrier.h"

pthread_mutex_t lock;

long double * commArray;  // the array to allow inter-thread communication
// TODO: Works but breaks with odd number of processes
/* Reduces local sums in an array
* @param: long double commArray[]: the array of values to reduce
* @param: unsigned long numThreads: the number of threads that are reducing
* @param: unsigned long id: the id of the thread "currently" running this function call
* @returns: a long double representing the reduction sum of the array
* Note: This algorithm should perform in O(log(n)) as long as there are enough cores to run the threads
*/
void pthreadReductionSum(long double localSum, unsigned long numThreads, unsigned long id, volatile long double * pi) {
	
	if (id == 0) {
		commArray = malloc(sizeof(long double) * numThreads);
	}
	pthreadBarrier(numThreads);
	commArray[id] = localSum;
	
	// multiply by 2 for correct number of iterations
	for (int i = 2; i < numThreads * 2; i *= 2) {
		pthreadBarrier((numThreads * 2 ) / i);
		
		// this checks if we are the "last" member of this stage in the reduction
		// otherwise we know our partner
		if (id % i == 0 && (id + i/2 < numThreads)) {
			commArray[id] += commArray[id + i/2];
		}
		else break;
	}
    barrierCleanup();
	if (id == 0) {
		*pi = commArray[0];
		free(commArray);
	}
}
]0;djv78@maroon33: ~/Documents/GitHub/CS374Work/hw6[01;32mdjv78@maroon33[00m:[01;34m~/Documents/GitHub/CS374Work/hw6[00m$ make
mpicc -Wall -ansi -pedantic -std=c99 -I/opt/openmpi/include calcPI2.c -o calcPI2 -lpthread -lmpi
]0;djv78@maroon33: ~/Documents/GitHub/CS374Work/hw6[01;32mdjv78@maroon33[00m:[01;34m~/Documents/GitHub/CS374Work/hw6[00m$ ./calcPI2 1000000000 4
Estimation of pi is 3.141592653589793591745876755184 in 1.430420 secs
(actual pi value is 3.141592653589793238462643383279...)
]0;djv78@maroon33: ~/Documents/GitHub/CS374Work/hw6[01;32mdjv78@maroon33[00m:[01;34m~/Documents/GitHub/CS374Work/hw6[00m$ exit

Script done on 2021-10-27 11:18:34-04:00 [COMMAND_EXIT_CODE="0"]
